---
title: "Data Visualization"
format: html
#code-fold: true
editor: visual
---

# Introducing ggplot

**ggplot2** is the most widely used data-visualization package in R. At the heart of it is the ggplot() function. The “gg” stands for the grammar of graphics, a way of building plots by combining clear components (data, mappings, geometric shapes, scales, and more). Instead of drawing a figure in one step, you assemble it layer by layer. This might feel unusual at first, but it gives you enormous flexibility.

Another big advantage is that **ggplot2** works beautifully with the **tidyverse** ecosystem. Many companion packages extend what you can do—adding new themes, annotations, color systems, interactivity, and specialized plot types.

There are several resources and tutorials where you can learn more about ggplot:

-   [ggplot2](https://ggplot2.tidyverse.org)
-   [The R Graph Gallery](https://r-graph-gallery.com)
-   [dataviz](https://www.data-to-viz.com/caveats.html)
-   [R for Data Science](https://r4ds.hadley.nz/data-visualize.html)

**Installation**

The easiest way to get ggplot2 is to install the whole **tidyverse** (install.packages("tidyverse")). Alternatively, install just **ggplot2** (install.packages("ggplot2")).

# Basics of ggplot

Plotting with **ggplot2** is based on building a figure by adding layers. Each new part of the plot is added to the previous ones using the plus sign (`+`).

Instead of drawing everything in a single command, you start with a base plot and then keep improving it step by step. The final result is a plot object that you can save, print, modify, or export.

Even though ggplot figures can become very sophisticated, most of them follow a simple structure.

**Basic skeleton code:**

```{r, eval=FALSE}
# plot data from my_data columns as red points
ggplot(data = my_data)+                   # use the dataset "my_data"
  geom_point(                             # add a layer of points (dots)
    mapping = aes(x = var1, y = var2),    # "map" data column to axes
    color = "red")+                       # other specification for the geom
  labs()+                                 # here you add titles, axes labels, etc.
  theme()                                 # here you adjust color, font, size etc of non-data plot elements (axes, title, etc.) 
```

# Total population data from **tidycensus** 

Now that we want to look at population data for many years, it would be tedious and repetitive to call `get_acs()` separately for each year. Instead of doing it manually, we can automate the process by “mapping” a function over a vector of years. This way, the same code runs for each year, and we can collect all the results in a single dataset efficiently.

In **purrr** package, `map()` is a tool for repeating a function over a list or vector of inputs. Instead of writing a loop, you can apply a function to every element and get a list of results. It makes your code shorter, cleaner, and easier to read. See additional resources: [Purrr in R](https://medium.com/@ozturkfemre/purr-in-r-a-powerful-tool-for-iteration-d4eb6c0b2d20) and [map functions](https://purrr.tidyverse.org/reference/map_dfr.html).

Sometimes, the output of `map()` is a list of data frames. That’s useful, but often we want a single, combined data frame to work with in tidyverse pipelines. That’s where `map_df()` comes in. 

`map_df()` does the same job as `map()`, but it automatically binds all the results together row-wise into one tidy data frame. This is perfect for our population example, where we pull data for multiple years and want a single dataset with a “year” column.

The `map()` function takes the following arguments:

- .x: The data structure to which the function to be applied will be applied 
- .f: The function to apply
- ...: Additional arguments required by the function

In the code below:

- we map a function over every year in `years`
- for each year, we pull total population with `get_acs()`
- `map_df()` combines all the results into one single data frame `pop_state`


```{r}
library(tidycensus) # load packages
library(tidyverse)
library(purrr)
```

Get the data we will plot: 

```{r, warning=FALSE}
# choose the years you want
years <- 2012:2022

pop_state <- map_df(years, function(y) {
  get_acs(
     geography = "state",
     variables = "B01003_001",
     year = y,
     survey = "acs5") %>%
     select(GEOID, NAME, estimate) %>%
     mutate(year = y)})

unique(pop_state$year)
```

Simplified example using `map_df()`:

- input vector: 1, 2, 3
- function: square of x
- output: a single data frame; `map_df()` stacks them

```{r}
map_df(1:3, function(x) {tibble(number = x, square = x^2) })
```

Let's create a few subset of the data:

```{r}
tn <- pop_state %>% # only TN
  filter(NAME == "Tennessee") %>%
  rename(pop = estimate)

# select 3 states
tn_ga_sc <- pop_state %>%
  filter(NAME %in% c("Tennessee", "Georgia", "South Carolina")) %>%
  rename(pop = estimate)
```

# Creating a ggplot

When working with **ggplot2**, every plot starts with the ggplot() function. Think of this as setting up a blank canvas. Inside `ggplot()`, the first thing we tell R is which dataset we want to use (e.g., `tn`).

The code below creates an empty plot that’s connected to the `tn` dataset.
Right now, nothing appears on the screen. This is because we’ve told R what data to use, but we haven’t told it how to display it yet.

The magic of ggplot happens when we start adding layers to show the data visually.

```{r}
ggplot(tn)
```

Next, we need to tell `ggplot()` how we want our data to appear on the graph.
This is where aesthetic mappings come in. In ggplot, we use the `aes()` function (short for “aesthetics”) to explain how variables in our dataset should be connected to visual elements in the plot.

```{r}
ggplot(data = tn,
       mapping = aes(x = year, y = pop)) # what happen with year?

ggplot(data = tn,
       mapping = aes(x = year, y = pop)) +
  scale_x_continuous(breaks = seq(min(tn$year), max(tn$year), by = 2))
```

Now we need to choose a *geom* (short for geometric object). A *geom* is simply the type of shape that ggplot uses to display your data. 

In ggplot2, *geoms* are added with functions that start with `geom_`. For example:
- Bar charts use `geom_bar()`
- Line charts use `geom_line()`
- Boxplots use `geom_boxplot()`
- Scatterplots use `geom_point()`

So when you decide what kind of plot you want, you’re really deciding which geom to add.

```{r}
ggplot(
  data = tn,
  mapping = aes(x = year, y = pop)) +
  scale_x_continuous(breaks = seq(min(tn$year), max(tn$year), by = 1)) +
  geom_line()
  
ggplot(
  data = tn,
  mapping = aes(x = year, y = pop)) +
  scale_x_continuous(breaks = seq(min(tn$year), max(tn$year), by = 1)) +
  geom_point()
```

# Adding aesthetics and layers

Now, we want to change the appearance of the line and the axis labels. Note that:

- When we put `color = "blue"` inside `geom_line()` but outside `aes()`, we are setting a fixed color
- If we put color inside `aes()`, ggplot would expect a variable and would color lines based on data

```{r}
ggplot(
  data = tn,
  mapping = aes(x = year, y = pop)) +
  scale_x_continuous(breaks = seq(min(tn$year), max(tn$year), by = 1)) +
  geom_line(color = "blue") +
  labs(x = "Year", y = "Population")
```

Now, instead of looking at just one state, we’re using a dataset that includes three states. We want one line for each state so we can compare them over time.

```{r}
ggplot(
  data = tn_ga_sc,
  mapping = aes(x = year, y = pop, colour = NAME)) +
  scale_x_continuous(breaks = seq(min(tn$year), max(tn$year), by = 1)) +
  geom_line() +
  labs(x = "Year", y = "Population")
```

Large numbers can make a graph harder to read. So, instead of plotting large values, we can rescale the data to make the axis cleaner and easier to interpret.

```{r}
summary(tn_ga_sc$pop)

tn_ga_sc <- tn_ga_sc %>%
  mutate(pop2 = pop/1000) 

ggplot(
  data = tn_ga_sc,
  mapping = aes(x = year, y = pop2, colour = NAME)) +
  scale_x_continuous(breaks = seq(min(tn$year), max(tn$year), by = 1)) +
  geom_line() +
  labs(x = "Year", y = "Population (thousands)")
```

What if we want to move the legend to the bottom? We can use `theme()` function.

```{r}
ggplot(
  data = tn_ga_sc,
  mapping = aes(x = year, y = pop2, colour = NAME)) +
  scale_x_continuous(breaks = seq(min(tn$year), max(tn$year), by = 1)) +
  geom_line() +
  labs(x = "Year", y = "Population (thousands)") + 
  theme(legend.position = "bottom")
```

